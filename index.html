<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Subnetting 2 2026er</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #f4f7f6;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 { color: #2c3e50; margin-bottom: 20px; font-size: 1.6rem; }
    .quiz-card {
      background: white; padding: 30px 35px; border-radius: 15px;
      box-shadow: 0 10px 20px rgba(0,0,0,0.1); width: 100%; max-width: 820px;
    }
    .task-block {
      background: #eaf4fb; border-left: 4px solid #3498db;
      border-radius: 8px; padding: 14px 18px; margin-bottom: 24px;
    }
    .task-block .ip-line { font-size: 1.05rem; color: #555; margin-bottom: 6px; }
    .task-block .ip-line span { font-weight: bold; color: #2c3e50; }
    .task-block .task-line { font-size: 1rem; color: #555; }
    .task-block .task-line span { color: #3498db; font-weight: bold; }
    .section-label {
      font-size: 0.78rem; color: #7f8c8d; text-transform: uppercase;
      letter-spacing: 0.5px; margin-top: 20px; margin-bottom: 6px; font-weight: 600;
    }
    input[type="text"] {
      padding: 8px 10px; font-size: 0.95rem; border: 1px solid #ddd;
      border-radius: 6px; font-family: 'Segoe UI', sans-serif;
      box-sizing: border-box; transition: border-color 0.2s;
      outline: none; background: #fff; color: #2c3e50;
    }
    input[type="text"]:focus { border-color: #3498db; }
    input[type="text"]::placeholder { color: #bdc3c7; }
    input[type="text"].correct   { border-color: #27ae60; background: #eafaf1; }
    input[type="text"].incorrect { border-color: #e74c3c; background: #fdedec; }
    input.helper {
      background: #f8f9fa; border: 1px dashed #bdc3c7; font-family: monospace;
      font-size: 0.82rem; letter-spacing: 1px; text-align: center; color: #7f8c8d;
    }
    input.helper:focus { border-color: #3498db; color: #2c3e50; }
    input.helper::placeholder { color: #ccc; }
    input.helper.correct   { border-color: #27ae60 !important; background: #eafaf1; color: #27ae60; }
    input.helper.incorrect { border-color: #e74c3c !important; background: #fdedec; color: #e74c3c; }
    .mask-row { display: flex; align-items: center; gap: 12px; margin-top: 10px; }
    .mask-row label { min-width: 200px; font-size: 0.9rem; color: #555; }
    .mask-row input { flex: 1; }
    .octet-row { display: flex; gap: 8px; margin-top: 6px; }
    .octet-wrap { display: flex; flex-direction: column; align-items: center; flex: 1; }
    .octet-wrap input { width: 100%; text-align: center; }
    .power-row { display: flex; align-items: center; gap: 10px; margin-top: 8px; }
    .power-row .base-label { font-size: 1.2rem; color: #3498db; font-weight: bold; }
    .power-row input.small-field { width: 58px; text-align: center; }
    .power-row .gte  { font-size: 1.1rem; color: #3498db; font-weight: bold; }
    .power-row .seg-num { font-size: 1.1rem; color: #2c3e50; font-weight: bold; }
    .section-title { font-size: 0.95rem; color: #2c3e50; font-weight: 700; margin-top: 22px; margin-bottom: 8px; }
    .quiz-table-wrap { border-radius: 8px; overflow: hidden; border: 1px solid #eee; }
    .quiz-table { width: 100%; border-collapse: collapse; font-family: 'Segoe UI', sans-serif; }
    .quiz-table thead tr { background: #f8f9fa; }
    .quiz-table thead th {
      padding: 8px 10px; font-size: 0.78rem; color: #7f8c8d;
      text-transform: uppercase; letter-spacing: 0.4px; text-align: center;
      border-bottom: 1px solid #eee; font-weight: 600;
    }
    .quiz-table tbody tr:nth-child(even) { background: #fafafa; }
    .quiz-table tbody tr:nth-child(odd)  { background: #fff; }
    .quiz-table tbody tr:hover           { background: #eaf4fb; }
    .quiz-table td { padding: 6px 8px; text-align: center; vertical-align: middle; border-bottom: 1px solid #f0f0f0; }
    .bin-static { font-family: monospace; font-size: 0.95rem; color: #2c3e50; letter-spacing: 2px; }
    .tbl-dec   { width: 64px; font-size: 0.88rem; padding: 5px; text-align: center; }
    .tbl-small { width: 56px; font-size: 0.88rem; padding: 5px; text-align: center; }
    .range-wrap { display: flex; align-items: center; gap: 4px; justify-content: center; }
    .range-wrap .dash { color: #bdc3c7; font-size: 1rem; }
    .sn-cell { color: #7f8c8d; font-weight: bold; font-size: 0.9rem; width: 32px; }
    .prefix-cell { display: flex; align-items: center; gap: 1px; justify-content: center; flex-wrap: nowrap; }
    .prefix-cell .fixed { color: #3498db; font-size: 0.83rem; white-space: nowrap; font-family: monospace; font-weight: 600; }
    .prefix-cell input.var-octet { width: 42px; font-size: 0.83rem; padding: 5px 3px; text-align: center; }
    .prefix-cell .dot { color: #bdc3c7; font-size: 0.9rem; }
    .btn-row { display: flex; justify-content: center; margin-top: 28px; }
    button.btn-check {
      background: #3498db; color: white; border: none; padding: 12px 40px;
      border-radius: 8px; cursor: pointer; font-size: 1rem; font-weight: 600;
      transition: background 0.3s, transform 0.1s;
    }
    button.btn-check:hover  { background: #2980b9; }
    button.btn-check:active { transform: scale(0.97); }
    .feedback { text-align: center; margin-top: 14px; font-size: 0.95rem; font-weight: bold; min-height: 22px; }
    .feedback.ok  { color: #27ae60; }
    .feedback.err { color: #e74c3c; }
    .spacer { margin-top: 18px; }
    hr.divider { border: none; border-top: 1px solid #eee; margin: 22px 0 0 0; }
  </style>
</head>
<body>
  <h1>Subnetting 2 2026er</h1>
  <div class="quiz-card">

    <div class="task-block">
      <div class="ip-line">IP: <span id="ip-display"></span></div>
      <div class="task-line">Deine Aufgabe: Teile das Netzwerk in <span id="segment-count"></span> Segmente</div>
    </div>

    <div class="mask-row">
      <label>Netzanteil</label>
      <input type="text" id="net-part" placeholder="z.B. 24" maxlength="2" />
    </div>
    <div class="mask-row" style="margin-top:8px;">
      <label>Hostanteil</label>
      <input type="text" id="host-part" placeholder="z.B. 8" maxlength="2" />
    </div>

    <div class="spacer"></div>

    <div class="section-label">Subnetzmaske (alt, binär)</div>
    <div class="octet-row">
      <div class="octet-wrap"><input type="text" class="helper" id="mask-old-b1" placeholder="11111111" maxlength="8" /></div>
      <div class="octet-wrap"><input type="text" class="helper" id="mask-old-b2" placeholder="11111111" maxlength="8" /></div>
      <div class="octet-wrap"><input type="text" class="helper" id="mask-old-b3" placeholder="11111111" maxlength="8" /></div>
      <div class="octet-wrap"><input type="text" class="helper" id="mask-old-b4" placeholder="00000000" maxlength="8" /></div>
    </div>
    <div class="mask-row" style="margin-top:8px;">
      <label>Subnetzmaske (alt, dezimal)</label>
      <input type="text" id="mask-old-dec" placeholder="z.B. 255.255.255.0" />
    </div>

    <div class="spacer"></div>

    <div class="power-row">
      <span class="base-label">2^</span>
      <input type="text" class="small-field" id="n-bits" placeholder="n" maxlength="2" />
      <span class="gte">&gt;=</span>
      <span class="seg-num" id="seg-num-display"></span>
    </div>

    <div class="section-label" style="margin-top:18px;">Subnetzmaske (neu, binär)</div>
    <div class="octet-row">
      <div class="octet-wrap"><input type="text" class="helper" id="mask-new-b1" placeholder="11111111" maxlength="8" /></div>
      <div class="octet-wrap"><input type="text" class="helper" id="mask-new-b2" placeholder="11111111" maxlength="8" /></div>
      <div class="octet-wrap"><input type="text" class="helper" id="mask-new-b3" placeholder="11111111" maxlength="8" /></div>
      <div class="octet-wrap"><input type="text" class="helper" id="mask-new-b4" placeholder="00000000" maxlength="8" /></div>
    </div>
    <div class="mask-row" style="margin-top:8px;">
      <label>Subnetzmaske (neu, dezimal)</label>
      <input type="text" id="mask-new-dec" placeholder="z.B. 255.255.255.224" />
    </div>

    <div class="spacer"></div>

    <div class="section-title">Schrittgröße berechnen</div>
    <div class="quiz-table-wrap">
      <table class="quiz-table">
        <thead>
          <tr>
            <th id="bin-col-header">Binär</th>
            <th>Schritte</th>
            <th colspan="3">IP-Bereich</th>
          </tr>
        </thead>
        <tbody id="step-table-body"></tbody>
      </table>
    </div>

    <div class="spacer"></div>

    <div class="section-title">Subnetze</div>
    <div class="quiz-table-wrap">
      <table class="quiz-table">
        <thead>
          <tr>
            <th>SN</th>
            <th>NetzID</th>
            <th>Erster Host</th>
            <th>Letzter Host</th>
            <th>Broadcast</th>
          </tr>
        </thead>
        <tbody id="subnet-table-body"></tbody>
      </table>
    </div>

    <div class="btn-row">
      <button class="btn-check" id="btn-check">Überprüfen</button>
    </div>
    <div class="feedback" id="feedback"></div>
    <hr class="divider" />
  </div>

<script>
function dec2bin8(n) { return n.toString(2).padStart(8,'0'); }
function toBin(val, bits) { return val.toString(2).padStart(bits,'0'); }
function cidrToMask(cidr) {
  return [0,1,2,3].map(i => { let b=Math.min(8,Math.max(0,cidr-i*8)); return 256-Math.pow(2,8-b); });
}
function extraBits(n) { let b=1; while(Math.pow(2,b)<n) b++; return b; }

function offsetToIP(base, offset) {
  let a = base[3]+offset;
  let o4=a%256; let c=Math.floor(a/256);
  let o3=(base[2]+c)%256; c=Math.floor((base[2]+c)/256);
  let o2=(base[1]+c)%256; c=Math.floor((base[1]+c)/256);
  let o1=(base[0]+c)%256;
  return [o1,o2,o3,o4];
}

function rnd(min, max) { return min + Math.floor(Math.random()*(max-min+1)); }

// Generate a random task with varied CIDR and varied IPs
// Rules:
//  - CIDR between 8 and 26 (so subnetting stays within /8 to /29, learnable range)
//  - The step octet must stay within a single octet (newCidr <= stepOctetIdx*8 + 8)
//    → keeps the exercise clean: step values are always 0-255
//  - IP is randomised within private ranges with random host parts zeroed to align with CIDR
function generateTask() {
  let task;
  let tries = 0;
  do {
    tries++;
    const segments = rnd(2, 10);
    const extra    = extraBits(segments);

    // Pick a CIDR from a broad realistic set: 8, 9..15, 16, 17..23, 24, 25, 26
    // But ensure stepOctetIdx * 8 + 8 > newCidr (step stays in one octet)
    // stepOctetIdx = floor(cidr/8)
    // newCidr = cidr + extra
    // Condition: newCidr <= (stepOctetIdx+1)*8  →  cidr + extra <= floor(cidr/8)*8 + 8
    // This is satisfied when extra <= 8 - (cidr % 8)
    // So: cidr % 8 <= 8 - extra
    // For extra=1 → cidr%8 <= 7 (always ok)
    // For extra=2 → cidr%8 <= 6
    // For extra=3 → cidr%8 <= 5
    // For extra=4 → cidr%8 <= 4

    const cidr = rnd(8, 26);
    const stepOctetIdx = Math.floor(cidr/8);
    const newCidr = cidr + extra;

    // Reject if subnetting spills into next octet
    if (newCidr > (stepOctetIdx+1)*8) continue;
    // Reject if newCidr > 30 (would leave < 2 host bits)
    if (newCidr > 30) continue;

    // Build a random IP aligned to the cidr boundary
    // Use realistic private-ish ranges
    const firstOctetOptions = [10, 172, 192];
    let o1 = firstOctetOptions[rnd(0,2)];
    let o2, o3, o4;

    if (o1 === 10)  { o2 = rnd(0,9);  o3 = rnd(0,9);  o4 = 0; }
    if (o1 === 172) { o2 = rnd(16,31); o3 = rnd(0,9);  o4 = 0; }
    if (o1 === 192) { o2 = 168;        o3 = rnd(0,20); o4 = 0; }

    const ip = [o1, o2, o3, o4];

    // Zero out bits that fall within the host part according to cidr
    // For simplicity: zero octets beyond stepOctetIdx, keep step octet aligned
    for (let i = stepOctetIdx; i < 4; i++) ip[i] = 0;
    // For step octet: align to multiple of stepSize-in-octet
    const bitsInStepOctet = cidr % 8;
    if (bitsInStepOctet > 0) {
      const mask = (0xFF << (8-bitsInStepOctet)) & 0xFF;
      ip[stepOctetIdx] = ip[stepOctetIdx] & mask;
    }

    const stepSize    = Math.pow(2, 32-newCidr);
    const oldMask     = cidrToMask(cidr);
    const newMask     = cidrToMask(newCidr);
    let prefixParts   = [];
    for (let i=0; i<stepOctetIdx; i++) prefixParts.push(ip[i]);
    const fixedPrefix = prefixParts.length>0 ? prefixParts.join('.')+'.' : '';

    task = { ip, cidr, segments, extra, newCidr, stepSize,
             stepOctetIdx, oldMask, newMask, fixedPrefix,
             ipStr: ip.join('.')+'/'+cidr };
  } while (!task && tries < 200);

  if (task) TASK = task;
}

let TASK = {};

function renderTask() {
  const t = TASK;
  document.querySelectorAll('input[type="text"]').forEach(el=>{ el.value=''; el.classList.remove('correct','incorrect'); });
  document.getElementById('feedback').textContent='';
  document.getElementById('feedback').className='feedback';
  document.getElementById('ip-display').textContent      = t.ipStr;
  document.getElementById('segment-count').textContent   = t.segments;
  document.getElementById('seg-num-display').textContent = t.segments;

  document.getElementById('bin-col-header').innerHTML =
    '<span style="color:#3498db;font-family:monospace;font-weight:600;">'+t.fixedPrefix+'</span>'
    + 'X'.repeat(t.extra);

  // Step table
  const stepBody = document.getElementById('step-table-body');
  stepBody.innerHTML = '';
  for (let i=0; i<t.segments; i++) {
    const ss  = offsetToIP(t.ip, i*t.stepSize);
    const se  = offsetToIP(t.ip, i*t.stepSize+t.stepSize-1);
    const bin = toBin(i, t.extra);
    const ph1 = i===0 ? 'z.B. '+ss[t.stepOctetIdx] : '';
    const ph2 = i===0 ? 'z.B. '+se[t.stepOctetIdx] : '';
    const tr  = document.createElement('tr');
    tr.innerHTML = `
      <td><span class="bin-static">${bin}</span></td>
      <td><input type="text" class="tbl-dec"   id="step-dec-${i}"  placeholder="" maxlength="3" /></td>
      <td><div class="range-wrap">
        <input type="text" class="tbl-small" id="step-from-${i}" placeholder="${ph1}" maxlength="3" />
        <span class="dash">–</span>
        <input type="text" class="tbl-small" id="step-to-${i}"   placeholder="${ph2}" maxlength="3" />
      </div></td>`;
    stepBody.appendChild(tr);
  }

  // Subnet table
  const subnetBody = document.getElementById('subnet-table-body');
  subnetBody.innerHTML = '';
  for (let i=0; i<t.segments; i++) {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="sn-cell">${i+1}</td>
      <td>${buildCell(i,'net-id',    0)}</td>
      <td>${buildCell(i,'first-host',1)}</td>
      <td>${buildCell(i,'last-host', t.stepSize-2)}</td>
      <td>${buildCell(i,'broadcast', t.stepSize-1)}</td>`;
    subnetBody.appendChild(tr);
  }
}

function buildCell(row, pfx, off) {
  const t = TASK;
  let html = '<div class="prefix-cell"><span class="fixed">'+t.fixedPrefix+'</span>';
  for (let v=t.stepOctetIdx; v<4; v++) {
    if (v>t.stepOctetIdx) html += '<span class="dot">.</span>';
    html += '<input type="text" class="var-octet" id="'+pfx+'-'+row+'-o'+v+'" placeholder="" maxlength="3" />';
  }
  return html + '</div>';
}

function chk(id, expected) {
  const el = document.getElementById(id);
  if (!el) return true;
  const ok = el.value.trim() === String(expected);
  el.classList.toggle('correct',   ok);
  el.classList.toggle('incorrect', !ok);
  return ok;
}

function validate() {
  const t = TASK;
  let allOk = true;
  allOk = chk('net-part',  t.cidr)    && allOk;
  allOk = chk('host-part', 32-t.cidr) && allOk;
  t.oldMask.map(dec2bin8).forEach((v,i) => { allOk = chk('mask-old-b'+(i+1), v) && allOk; });
  allOk = chk('mask-old-dec', t.oldMask.join('.')) && allOk;
  allOk = chk('n-bits', t.extra) && allOk;
  t.newMask.map(dec2bin8).forEach((v,i) => { allOk = chk('mask-new-b'+(i+1), v) && allOk; });
  allOk = chk('mask-new-dec', t.newMask.join('.')) && allOk;

  for (let i=0; i<t.segments; i++) {
    const ss = offsetToIP(t.ip, i*t.stepSize);
    const se = offsetToIP(t.ip, i*t.stepSize+t.stepSize-1);
    allOk = chk('step-dec-'+i,  ss[t.stepOctetIdx]) && allOk;
    allOk = chk('step-from-'+i, ss[t.stepOctetIdx]) && allOk;
    allOk = chk('step-to-'+i,   se[t.stepOctetIdx]) && allOk;
  }

  for (let i=0; i<t.segments; i++) {
    const offs = {'net-id':0,'first-host':1,'last-host':t.stepSize-2,'broadcast':t.stepSize-1};
    for (const [pfx, off] of Object.entries(offs)) {
      const ip = offsetToIP(t.ip, i*t.stepSize+off);
      for (let v=t.stepOctetIdx; v<4; v++) {
        allOk = chk(pfx+'-'+i+'-o'+v, ip[v]) && allOk;
      }
    }
  }

  const fb = document.getElementById('feedback');
  if (allOk) {
    fb.textContent = '✓ Alles richtig! Neue Aufgabe wird geladen…';
    fb.className   = 'feedback ok';
    setTimeout(() => { generateTask(); renderTask(); }, 1800);
  } else {
    fb.textContent = '✗ Einige Felder sind noch nicht korrekt. Rot markierte Felder korrigieren.';
    fb.className   = 'feedback err';
  }
}

document.getElementById('btn-check').addEventListener('click', validate);
generateTask();
renderTask();
</script>
</body>
</html>
